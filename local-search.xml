<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2023/02/07/%E6%A0%91/"/>
    <url>/2023/02/07/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/../img/QQ%E5%9B%BE%E7%89%8720230207203748.png" alt="树的示意图"></p><p>逻辑上是这个结构的就称为树</p>]]></content>
    
    
    <categories>
      
      <category>---数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>---数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2023/02/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/02/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>多个字符(char变量)组成</p><p>主串 beijing, 子串 eijing,子串位置就是第一个字符的位置</p><p>空格在字符串里不能忽略，“beijing”不等于“bei jing”</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>一般使用string类，或者char *也就是字符数组。但是二者有小区别</p><p>当执行下面的语句后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">String  s1 = <span class="hljs-string">&quot;value-&quot;</span>;c<br>s2 = s1.<span class="hljs-built_in">Substr</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><img src="/../img/QQ%E5%9B%BE%E7%89%8720230207164152.png" alt="示意图"></p><p>string是基于char编成的类，但是在最后一个位置加‘\0’</p><p>这可以作为我们字符串循环终止的一种条件</p><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配就是在主串里找子串</p><h3 id="简单匹配"><a href="#简单匹配" class="headerlink" title="简单匹配"></a>简单匹配</h3><p>从第一个字母开始比较，然后一直比较到最后一个字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">matching</span><span class="hljs-params">(string T,string P)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t=T.<span class="hljs-built_in">lenth</span>();<br>    <span class="hljs-type">int</span> p=P.<span class="hljs-built_in">lenth</span>();<br>    <span class="hljs-keyword">if</span>(t&lt;p)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;t&amp;&amp;j&lt;p)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(T[i]==P[j])<br>        &#123;<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            j=<span class="hljs-number">0</span>;<br>            i=i-j+<span class="hljs-number">1</span>;<span class="hljs-comment">//表示i-j匹配失败，返回到i-j+1继续比较</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j==p)<br>        <span class="hljs-keyword">return</span> i-j;<span class="hljs-comment">//表示i-j匹配成功</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最坏情况下要比较(t-p+1)(p),算法复杂度为O(t*p)</p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>如果字符串里面有很多重复的是时候，那么直接设置j&#x3D;0，则会造成很多的重复。</p><p>KMP算法通过确定一个字符串重复的特征来确定回溯的值，避免重复</p><h5 id="特征向量"><a href="#特征向量" class="headerlink" title="特征向量"></a>特征向量</h5><p>特征向量的值就是回溯的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *Next=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>Next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>    Next[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//把特征向量数组·进行初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>i&lt;n;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(P[i]==P[Next[i<span class="hljs-number">-1</span>])<br>     Next[i]=Next[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<span class="hljs-comment">//如果这两个值相等，那么说明这个位置重复的字符串长度比前一个位置长1</span><br>     <span class="hljs-keyword">else</span><br>               &#123;<br>                <span class="hljs-type">int</span> k=Next[i<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">while</span>(k)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(P[k]==P[i])<br>                        Next[i]=k;<br>                    <span class="hljs-keyword">else</span><br>                        k=Next[k];<br>                &#125;<br>               &#125;<span class="hljs-comment">//这个相当于在子串里面求模式匹配，而且是在已经求得特征值得字符串里面求，那么就直接利用KMP的思想回溯求</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个想法的核心是如果一个子串内前面和后面的字符串有一部分是相同的，那么相同的地方就不用再比较了，字符串的长度就是应该下次比较的值。当然这是因为c++数组是从0开始计数，刚好可以找到正确的位置</p><h4 id="KMP的匹配"><a href="#KMP的匹配" class="headerlink" title="KMP的匹配"></a>KMP的匹配</h4><p>就是用上面的方法来求出特征向量，然后再j处出现问题的时候，那么就把j回溯到Next[j-1]处，i是不回溯的。</p><p>显然可以看出算法复杂度是O(t+p)</p>]]></content>
    
    
    <categories>
      
      <category>---数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>---数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列</title>
    <link href="/2023/02/07/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2023/02/07/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数据在存入和取出时有一定顺序，先入后出为栈，先入先出为队列</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><p>栈根据采用的存储方式分为链式栈和顺序栈。简单定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> data;<br>    Node* link=<span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br>    <span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;<br>    Node *top=<span class="hljs-literal">NULL</span>;<br>    <br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>       Node*p=<span class="hljs-keyword">new</span> Node;<br>        p-&gt;data=x;<br>        p-&gt;link=top;<br>        top=p;<br>        size++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node*p=top;<br>        x=p-&gt;data;<br>        top=top-&gt;link;<br>        <span class="hljs-keyword">delete</span> p;<br>        size--;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>        <br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是简单用链表实现两个核心操作，并不完善。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>数制转换：10进制数变为其他进制数的方式就是求模，然后在进行倒过来对余数进行输出，那么每次的余数就可以存在栈里，倒过来输出</li><li>迷宫，用栈存入已经走过的路径，如果走到不能动的地方，退出这个位置，从栈顶的位置在走</li><li>括号匹配，遇到左括号存进去，然后碰到右括号弹出，这样就保证括号是匹配的</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="定义方式-1"><a href="#定义方式-1" class="headerlink" title="定义方式"></a>定义方式</h3><p>按存储方式数组和链表分为顺序队列和链式队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> data;<br>    Node* link=<span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <br>&#123;<br>    <span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;<br>    Node *rear=<span class="hljs-literal">NULL</span>;<br>    Node *front=<span class="hljs-literal">NULL</span>;<br>    <br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>       Node*p=<span class="hljs-keyword">new</span> Node;<br>        p-&gt;data=x;<br>        rear-&gt;link=p;<br>        rear=p;<br>        size++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node*p=front;<br>        x=p-&gt;data;<br>        front=front-&gt;link;<br>        <span class="hljs-keyword">delete</span> p;<br>        size--;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>        <br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要设置一个队头和队尾的指针</p><p>这里是链式队列，顺序队列可能会出现溢出，所以在每次存入时就会对存入的的位置进行求模，这样就避免冲突，这样在逻辑上就形成了环形队列</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>打印帕斯卡三角形。因为是把一堆数用完然后再按照顺序进行相加，方法非常类似队列。因此可以把第一行的数值入队，每次弹出一个值，再与队列顶部的元素相加再入队，为了方便，我们可以加一行0进行计算，这样就避免队列为0的情况</p>]]></content>
    
    
    <categories>
      
      <category>---数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>---数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二项式系数</title>
    <link href="/2023/02/07/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0/"/>
    <url>/2023/02/07/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="二项式系数"><a href="#二项式系数" class="headerlink" title="二项式系数"></a>二项式系数</h1><h2 id="帕斯卡三角形"><a href="#帕斯卡三角形" class="headerlink" title="帕斯卡三角形"></a>帕斯卡三角形</h2><p><img src="/../img/QQ%E5%9B%BE%E7%89%8720230207115106.jpg" alt="帕斯卡三角形"></p><h2 id="基本恒等式"><a href="#基本恒等式" class="headerlink" title="基本恒等式"></a>基本恒等式</h2><h3 id="对称恒等式"><a href="#对称恒等式" class="headerlink" title="对称恒等式"></a>对称恒等式</h3><p>$$<br>\left(\begin{matrix}<br>n\<br>k\<br>\end{matrix}\right)&#x3D;<br>\left(\begin{matrix}<br>n\<br>n-k\<br>\end{matrix}\right)<br>$$</p><p>这个恒等式要求n大于等于0,因为n小于0的时候组合数等于0，这是由伽马函数决定的。</p><h3 id="吸收恒等式"><a href="#吸收恒等式" class="headerlink" title="吸收恒等式"></a>吸收恒等式</h3><p>$$<br>\left(\begin{matrix}<br>n\<br>k<br>\end{matrix}\right)&#x3D;\frac{n}{k}<br>\left(\begin{matrix}<br>n-1\<br>k-1<br>\end{matrix}\right)<br>$$</p><p>该不等式在帕斯卡三角形中表示了同一对角线上元素的关系</p><h3 id="帕斯卡恒等式"><a href="#帕斯卡恒等式" class="headerlink" title="帕斯卡恒等式"></a>帕斯卡恒等式</h3><p>$$<br>\left(\begin{matrix}<br>n\<br>k<br>\end{matrix}\right)&#x3D;<br>\left(\begin{matrix}<br>n-1\<br>k<br>\end{matrix}\right)+<br>\left(\begin{matrix}<br>n-1\<br>k-1<br>\end{matrix}\right)<br>$$</p><p>组合意义就是在n个里面取k个可以看成是先取一个，如果它是我们要取得，就在n-1里取k-1个。如果不是就取k个</p><p>在帕斯卡三角形中表示的是一个元素在它上方的两个数字之和等于这个数</p><h4 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h4><ul><li><p>列求和<br>  $$<br>  \sum_{k\le n}\left(\begin{matrix}<br>  k\<br>  m<br>  \end{matrix}\right)&#x3D;<br>  \left(\begin{matrix}<br>  n+1\<br>  m+1<br>  \end{matrix}\right)<br>  $$<br>  这个等式是从等式右边的数据开始，每次都把自己上方的数字用帕斯卡等式展开。、</p><p>  作用就是用来列求和，或者说是上指标求和</p></li><li><p>对角线求和<br>  $$<br>  \sum_{k\le n}\left(\begin{matrix}<br>  k\<br>  m<br>  \end{matrix}\right)&#x3D;<br>  \left(\begin{matrix}<br>  n+1\<br>  m+1<br>  \end{matrix}\right)<br>  $$</p></li><li><p>差分</p><p>  将k看成是自变量的化，刚好满足差分的形式</p></li></ul><h3 id="二项式系数乘积"><a href="#二项式系数乘积" class="headerlink" title="二项式系数乘积"></a>二项式系数乘积</h3><p>$$<br>\left(\begin{matrix}<br>n\<br>m<br>\end{matrix}\right)<br>\left(\begin{matrix}<br>m\<br>k<br>\end{matrix}\right)<br>&#x3D;\left(\begin{matrix}<br>n\<br>k<br>\end{matrix}\right)<br>\left(\begin{matrix}<br>n-k\<br>m-k<br>\end{matrix}\right)<br>$$</p><p>​这个等式是表述了一个两次分类的问题，第一次就是在n个里面选m个为标记，然后再m个里面挑选k个作为第二类标记。这个方法等价于现在n个里挑选k个作为第二类标记，然后在n-k里挑选m-k个作为第一类标记</p>]]></content>
    
    
    <categories>
      
      <category>---Concrete Mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>---组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特殊数</title>
    <link href="/2023/02/06/%E7%89%B9%E6%AE%8A%E6%95%B0/"/>
    <url>/2023/02/06/%E7%89%B9%E6%AE%8A%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>#特殊数</p><h2 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h2><h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3>]]></content>
    
    
    <categories>
      
      <category>---Concrete Mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>---组合数学 --- 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2023/02/06/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2023/02/06/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数据在逻辑形式上是下面这样的就是线性表</p><pre><code class=" mermaid">flowchart LRa1 --&gt;a2 --&gt;a3 --&gt; a4 --&gt; a5</code></pre><p>存储结构</p><ul><li>链表：用结点类和指针实现</li><li>顺序表：用数组实现</li></ul><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>在计算机内存中，确定一个单元然后接着一个数据一个数据存，比如存入一个char型数据，假设计算机按字节编制，那么你存一个char型变量，这个变量在计算器中的存储地址就加1，也就是加所占的存储单元的个数</p><p>拓展到二维数组，其实他就是第一行存完再接着存第二行。计算数据所在地址大同小异。对于三维数组，那么就看成是多个二维数组，存完一个二维数组再接着存下一个。也就是一个立方体看成是n个面组成的，在计算机里编制是一层一层的</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入需要找到该元素所在位置，然后把在他之后的元素一个一个移动，假设找的是第i个位置，那么就要移动$n-i+1$次，假设我们查找的元素是等概率的，那么插入的复杂度就是：</p><p>​$\frac{1}{n+1}\sum_{i&#x3D;1}^{n}(n-i+1)$&#x3D;$\frac{n}{2}$</p><p>注意此处插入的位置是n+1，不是n</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>与插入同理，删除之后把后面的一个接一个向前移动。删除的位置只有n,移动 n-i 次，复杂度为：</p><p>​$\frac{1}{n}\sum_{i&#x3D;1}^{n}(n-i)$&#x3D;$\frac{n-1}{2}$</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点：可随机存取表中任意数据，算法简单，空间利用率高；可以直接获取线性表的长度</li><li>缺点：设置时需要预先知道要存的元素个数；删除插入算法复杂度高</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h4><p>链表编程时需要class或者struct一个结点，结点内存有指针域和数据域</p><table><thead><tr><th align="center">data</th><th align="center">link</th></tr></thead></table><p>link域可以是指向后驱结点的指针，也可以是前驱加后驱，两个都有的就称为是双向链表</p><p>存储时，我们需要设置一个头结点和一个尾结点。尾结点的link设置为null,这样在查找作为循环的终止条件</p><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>查找首先就是O(n)的不能直接找到我们要插入的元素的位置。</p><p>插入需要把插入结点的link指向该位置的后驱结点，然后把前驱结点的link指向插入的结点。这个复杂度是常数级的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">node0-&gt;link=node2;<br>node1-&gt;link=node1;<br></code></pre></td></tr></table></figure><p>这个代码是把结点0插入到1和2中</p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>删除大同小异</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p;<br>p=node1-link;<br>node1-&gt;link=node1-&gt;link-&gt;link;<br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p>这里必须释放node0,也就是删除。如果不用p这个指针，指向，那么在删除的时候就是会删除掉node2,要删除的node0就没有指向它的指针，那么就形成了内存泄漏。</p>]]></content>
    
    
    <categories>
      
      <category>---数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>---数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/05/hello-world/"/>
    <url>/2023/02/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>信息检索导论</title>
    <link href="/2023/02/04/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%AF%BC%E8%AE%BA/"/>
    <url>/2023/02/04/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="信息检索导论"><a href="#信息检索导论" class="headerlink" title="信息检索导论"></a>信息检索导论</h2><h2 id="第一章-布尔检索"><a href="#第一章-布尔检索" class="headerlink" title="第一章  布尔检索"></a>第一章  布尔检索</h2><p>###文本处理</p><ol><li>划分为词条</li><li>找到词条以及所在的文章，编成一个向量</li><li>建立倒排序索引,其实就是进行一个稀疏矩阵的压缩，可以在第一个节点处存入词条的频数、</li></ol><p>查询</p><ul><li>and</li><li>or</li></ul><p>###正确率和召回率</p><ul><li>正确率（Precision）：返回的结果中真正和信息需求相关的文档所占的百分比。</li><li>召回率（Recall）：所有和信息需求真正相关的文档中被检索系统返回的百分比</li></ul><h2 id="第二章-词项词典和倒排记录表"><a href="#第二章-词项词典和倒排记录表" class="headerlink" title="第二章 词项词典和倒排记录表"></a>第二章 词项词典和倒排记录表</h2><h3 id="文档分析和编码转换"><a href="#文档分析和编码转换" class="headerlink" title="文档分析和编码转换"></a>文档分析和编码转换</h3><p>​       字符序列生成</p><blockquote><blockquote><ol><li>对拿到的文件进行文件的转换，但是一般的厂家会给我们各种格式。可能遇到文本和非文本的文件，需要单独拿出非文本进行检测。注意有的文本文件我们也需要进行检测，例如&amp;和&amp;amp是一个意思。</li><li>尽可能的把要处理的文本变为现行的文本。比如阿拉伯语就是二维的，但是我们可以选择通过他的“拼音”来检测。</li></ol><p>索引粒度&#x2F;文档单位的选择</p><blockquote><ol><li>文档单位并不准确，因为有时候的文档所包含的内容并不统一，或多或少，一般采用索引粒度</li><li>索引粒度太小，正确率增高，召回率下降，索引力度太大，正确率降低，召回率升高。</li><li>索引粒度过大可以通过显示或隐式临近搜索来缓解。</li></ol></blockquote></blockquote></blockquote><h3 id="词项集合确定"><a href="#词项集合确定" class="headerlink" title="词项集合确定"></a>词项集合确定</h3><blockquote><ol><li>词条化<br> 就是将字符序列划分成一个个词条序列<br> 词条就是划分的子序列<br> 词条类就是同一词条的集合<br> 词条项就是归一化后的词条类</li><li>去除停用词<br> 停用词就是指那些出现频率高但意义不大的词条</li><li>词项归一化<br> 隐式建立等价类：一种是将意义相近的词映射为统一个词进行查询，这就是归一化，非归一化的方式就是在查询的过程中进行倒排记录表的合并，或者在查询前直接把词典合并</li><li>词干还原和词性归并<br> 词干还原比较粗暴，直接去除掉两端的前缀或后缀  Porter 算法，为了确定是否要删除一些东西，引入了词的测度<br> 词性归并要考虑英文的含义 saw-&gt;see,see-&gt;see<br> 进行归一化对于部分查询来说有帮助，但 是同时也会降低其他很多查询的效果。词干还原能够提高召回率但是会降低正确率</li></ol></blockquote><h3 id="基于跳表的倒排记录表的快速合并算法"><a href="#基于跳表的倒排记录表的快速合并算法" class="headerlink" title="基于跳表的倒排记录表的快速合并算法"></a>基于跳表的倒排记录表的快速合并算法</h3><blockquote><ul><li>在相隔一定距离的位置设置跳表。从一开始的跳表位置进行比较，直到两个倒排记录表找到相等的索引。</li><li>间隔一般取 $\sqrt{q}$</li><li>一般这个操作只用来执行and 操作，不执行or操作</li></ul></blockquote><h3 id="含位置信息的倒排记录表以及短语查询"><a href="#含位置信息的倒排记录表以及短语查询" class="headerlink" title="含位置信息的倒排记录表以及短语查询"></a>含位置信息的倒排记录表以及短语查询</h3><blockquote><ol><li>二元词索引<ul><li>将查询的短语分成每个单词的合并，stanford university palo alto变成“stanford university” AND “university palo” AND “palo alto”</li><li>有时候要查询的两个词中间可能会有一些虚词，比如the,of,等，所以在查询时，对要查询的文本进行此类划分，名词之间的虚词不管几个都看作一个来进行查询。也就是查询NX*N这样的类型</li></ul></li><li>位置信息索引</li><li>混合检索机制</li></ol></blockquote><h2 id="第三章-词典及容错式检索"><a href="#第三章-词典及容错式检索" class="headerlink" title="第三章 词典及容错式检索"></a>第三章 词典及容错式检索</h2><h3 id="词典搜索的数据结构"><a href="#词典搜索的数据结构" class="headerlink" title="词典搜索的数据结构"></a>词典搜索的数据结构</h3><blockquote><blockquote><ol><li>哈希表<br> 哈希表缺点是就是随着要搜索的词项不断增多，冲突难以避免，存在一个完美哈希的数据结构，但是很难实现。所以逐渐被搜索树替代。</li><li>搜索树<br> 主要是二叉搜索树，平衡树，b-树，b树的取值与磁盘有关。搜索树需要对数据进行提前排序</li></ol></blockquote></blockquote><h3 id="通配符查询"><a href="#通配符查询" class="headerlink" title="通配符查询"></a>通配符查询</h3><blockquote><blockquote><ul><li>通配符作用<br>  (1) 用户对查询的拼写不太确定（比如，如果 询 S*dney）； (2) 用户知道某 color 和 colour）； (3) 用户查找某个查询 引擎是否进行了词干还原（比如 judicial 和 judiciary，可采用通配符查询 judicia* ）； (4) 用户不确定一个外来词或者短语的正确拼写形式（如查询 Universit* Stuttgart）</li></ul></blockquote><blockquote><ul><li>通配符*，出现在末尾就查询前面的单词就行，出现在开头，则构建一个反向b树，将要查询的值反过来，在中间则同时使用这两种技术。</li></ul></blockquote></blockquote><h4 id="一般通配符的查询"><a href="#一般通配符的查询" class="headerlink" title="一般通配符的查询"></a>一般通配符的查询</h4><blockquote><blockquote><pre><code class="hljs">     1. 轮排索引</code></pre></blockquote><blockquote><pre><code class="hljs">   就是在一个词项后面加一个\$表示进行轮排索引，同时把词连带\$进行循环移位，产生的词项都放进字典进行查询。  2. K-gram   对于 castle 来说，所有的 3-gram包括\$ca、cas、ast、stl、tle 及 le\$,但是这么查询会造成召回率下降，因此还要通过后过滤的方式来校验。k表示的是字符的长度，注意这些字符是连着的</code></pre></blockquote></blockquote><h4 id="拼写矫正"><a href="#拼写矫正" class="headerlink" title="拼写矫正"></a>拼写矫正</h4><blockquote><blockquote><p>矫正条件：输入的词项其子序列可以单独搜索；没有该词项；找到的文档太少</p></blockquote><blockquote><ol><li>词项独立的矫正方法</li></ol></blockquote><blockquote><ul><li>编辑距离法<br>  编辑距离：插入，删除，替换的字母量。同时也可以为更改的字母加入权重。比如a-&gt;w的权重就比a-&gt;l的权重大，因为，前者在键盘上的距离更近</li></ul></blockquote><blockquote><p>​​具体实现：</p></blockquote><p>​            进行编辑距离的计算，如果一个一个比较那么算法复杂度在O($s_1$*$s_2$)d的复杂度，因此采用动态规划的方式，类似于弗洛伊德算法</p><blockquote><p>​​         找到最小距离最小的字符串。最简单就是和字符串集合里的字符进行比较，但太慢。所以我们可以借助轮排的思想，找轮排索引的词项，缩小查找范围。但是结果差距较大，所以我们在进行查找时，会对字符串一定长度的后缀进行舍弃。</p></blockquote><blockquote><ul><li>k-gram索引法<br>  实现方法：</li></ul></blockquote><blockquote><p>​​  直接运用k-gram索引的方式进行搜索</p></blockquote><blockquote><p>​​       用雅可比系数判定是否要返回，雅可比系数的计算公式为|A∩B|&#x2F;|A∪B|，其中 A、B 分别是查询 q、词汇表词项 中的 k-gram 集合，超出一定阈值就输出</p></blockquote><blockquote><p>​​        例：q &#x3D; board 扫描倒排记录表直到t &#x3D; boardroom。这时我们知道有 2 个 2-gram已经匹配上了。如果倒排记录 表中已经预先记录了boardroom所包含的 2-gram的数目（这里是 8），那么所有计算雅可比系数 的信息都已知，计算公式为：2&#x2F;（8+3-2）。</p></blockquote><blockquote><ol start="2"><li>上下文敏感的拼写矫正</li></ol><blockquote><p>用来处理输入了一个短语，但是短语的错误太多，此时就要用上面提到的方法返回可能正确的值，依次搜索出结果最多的作为搜索的结果</p></blockquote></blockquote></blockquote><h4 id="基于发音的矫正技术"><a href="#基于发音的矫正技术" class="headerlink" title="基于发音的矫正技术"></a>基于发音的矫正技术</h4><blockquote><blockquote><ul><li>基本思想：根据发音建立一个哈希表</li></ul><blockquote><ul><li>soundex算法：根据发音的方式进行编码，主要适用于欧洲人</li></ul></blockquote></blockquote></blockquote><h2 id="第四章-基于块的排序索引方法"><a href="#第四章-基于块的排序索引方法" class="headerlink" title="第四章 基于块的排序索引方法"></a>第四章 基于块的排序索引方法</h2><blockquote><ol><li>基于块的排序索引方法，类似于块排序，采用ID-ID的方式</li><li>内存式单遍扫描索引构建方法，依然分块，但是采用词项-ID的方式，每次读取块的时候才构建倒排记录表</li><li>分布式索引构建方法，就是扩展到计算机对web文本的处理</li><li>动态构建索引<br>第一种是直接周期的进行增加和删改<br>第二种是进行构建辅助索引。大索引，辅助索引，修改时修改辅助索引，使用时将二者合并，当辅助索引比大时，则变为大索引</li></ol></blockquote><h2 id="第五章-索引压缩"><a href="#第五章-索引压缩" class="headerlink" title="第五章 索引压缩"></a>第五章 索引压缩</h2><h3 id="信息检索中词项的统计特性"><a href="#信息检索中词项的统计特性" class="headerlink" title="信息检索中词项的统计特性"></a>信息检索中词项的统计特性</h3><h4 id="Heaps定律–对词项数目的估计"><a href="#Heaps定律–对词项数目的估计" class="headerlink" title="Heaps定律–对词项数目的估计"></a>Heaps定律–对词项数目的估计</h4><p>将词项大小按照文档集的数目进行估计，当文档的数目大于$10^{5}$时该定律基本与实际相符</p><p>​M&#x3D;k$T^b$</p><p><img src="C:/Users/E/AppData/Roaming/Typora/typora-user-images/image-20230118131123750.png" alt="image-20230118131123750"></p><p>T 是文档集合中的词条个数。参数 k 和 b 的典型取值为：30≤ k ≤ 100，b≈0.5。Heaps 定 律认为，文档集大小和词汇量之间可能存在的最简单的关系是它们在对数空间（log-log space） 中存在线性关系，并且这种线性关系往往和实际情况相吻合</p><p>该定理的两个基本假设：(i) 随着文档数目的增加，词汇量会持续增长而不会稳定到一个最大值；</p><p>​ (ii) 大规模文档集的词汇量也会非常大。</p><h4 id="Zipf-定律：对词项的分布建模"><a href="#Zipf-定律：对词项的分布建模" class="headerlink" title="Zipf 定律：对词项的分布建模"></a>Zipf 定律：对词项的分布建模</h4><p>该定律指出，词项的的频率与词项频率所处的频率的排名成反比,也就是在对数空间时是线性的</p><p>​cf i ∝ $1&#x2F;i$</p><p><img src="C:/Users/E/AppData/Roaming/Typora/typora-user-images/image-20230118131633420.png" alt="image-20230118131633420"></p><p>其实这个模型的预测很多地方并不准确</p><h3 id="词典压缩"><a href="#词典压缩" class="headerlink" title="词典压缩"></a>词典压缩</h3><h4 id="将词项看为一个字符串的压缩"><a href="#将词项看为一个字符串的压缩" class="headerlink" title="将词项看为一个字符串的压缩"></a>将词项看为一个字符串的压缩</h4><p>我们通常编字典词项的长度为20B,但是平均的长度只有8B,所以就把所有的词项看成一个字符串，用一个指针数组指向每一个词项的开头，开辟了3B的空间</p><h4 id="按块储存"><a href="#按块储存" class="headerlink" title="按块储存"></a>按块储存</h4><p>在上面的方法进行分块，并在每个块之前分配分配一个字节存储块内词项大小</p><p>也可以在分块的基础上进行下一步的改进，将块内的词项的公共词缀用一个特殊的符号代表</p><p>完美哈希不适用于动态的查找。</p><h3 id="倒排索引的压缩"><a href="#倒排索引的压缩" class="headerlink" title="倒排索引的压缩"></a>倒排索引的压缩</h3><p>基本事实，一般的字符频率较高的词项出现的文档ID的gap不大</p><h4 id="可变字节码"><a href="#可变字节码" class="headerlink" title="可变字节码"></a>可变字节码</h4><p>直接记录gap值，以1个字节作为记录单位，如果gap值不能被1B记录下来，那么就用多个字节来记录。每个字节前面的的第一个位用来标记是否为最后一个字节。</p><h4 id="gamma-编码"><a href="#gamma-编码" class="headerlink" title="$\gamma$ 编码"></a>$\gamma$ 编码</h4><p>仍然是对gap的编码，但是在开头使用一元编码，表示偏移的长度，也就是把正常数字的第一位去掉。</p><p>该编码由 一元编码+0+偏移长度 表示</p><p>该编码的长度在最优的长度的两倍左右。</p><p>但是是参数无关（适用于动态索引）以及前缀无关（唯一对应，切片反而会变慢）</p><h2 id="文档评分、词项权重计算及向量空间模型"><a href="#文档评分、词项权重计算及向量空间模型" class="headerlink" title="文档评分、词项权重计算及向量空间模型"></a>文档评分、词项权重计算及向量空间模型</h2><h4 id="参数化索引以及域索引"><a href="#参数化索引以及域索引" class="headerlink" title="参数化索引以及域索引"></a>参数化索引以及域索引</h4><p>元数据：与文档有关的数据，比如作者，日期。</p><p>参数化索引和域索引可以看为是自变量</p><h4 id="权重学习以及权重的确定"><a href="#权重学习以及权重的确定" class="headerlink" title="权重学习以及权重的确定"></a>权重学习以及权重的确定</h4><p>$tf_{t,d}$:在某一文档中词项频率</p><p>$cf$:指的是词项在文档中的频率</p><p>$df$：表示某一词项在文档集中出现的文档数目</p><p>$idf_{t,d}$(逆文档数)：$log(\frac{N}{df})$</p><p>$tf-idf_{t,d}$（词项权重）:$tf_{t,d}\times idf_{t,d}$</p><p>其特点：（1) 当 t 只在少数几篇文档中多次出现时，权重取值最大（此时能够对这些文档提供最强的 区分能力）； (2) 当 t 在一篇文档中出现次数很少，或者在很多文档中出现，权重取值次之（此时对最后 的相关度计算作用不大）； (3) 如果 t 在所有文档中都出现，那么权重取值最小。</p><p>一般权重可以由我们自己设置。但是也可以通过我们自己设置一个得分，然后通过线性回归的方式来学习一个权重。</p><p>得分就是把每个域的权重加起来</p><h4 id="向量空间模型"><a href="#向量空间模型" class="headerlink" title="向量空间模型"></a>向量空间模型</h4><p>该文档的向量就是把每个要查询的域的权重作为值设置为一个向量</p><p>一般采取上面的权重设置的方式</p>]]></content>
    
    
    
    <tags>
      
      <tag>---信息检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习初步及简单模型</title>
    <link href="/2023/02/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%AD%A5/"/>
    <url>/2023/02/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习初步"><a href="#机器学习初步" class="headerlink" title="机器学习初步"></a>机器学习初步</h1><h2 id="机器学习预备知识"><a href="#机器学习预备知识" class="headerlink" title="机器学习预备知识"></a>机器学习预备知识</h2><ul><li>监督学习：对这个机器学习有预期目标，比如回归问题<br>  无监督学习：没有目标，比如拿到数据只进行一个分类</li><li>归纳偏好：每个算法对于一个问题都有自己的结果风格</li><li>NFL原理（No Free Lunch):一个算法在一个方面上劣于另一个算法，那么在另一个方面一定优于另一个算法</li><li>泛化性：在对未知数据的处理能力</li><li>评估方法<ul><li>留出法（hold-out):对每次对所使用的数据集进行分割，一部分用于测试，一部分用于训练。如果训练的数据太多，M’对M的近似效果就下降，如果训练太少，误差的近似就会下降。因此恰当选取0.2做测试集，或者1&#x2F;3.同时需要多次随机进行抽取数据做测试集来进行实验，至少100次。</li><li>交叉验证法（cross-validation)：把每次的数据分成n个小组，每个都循环的作为测试集和训练集。划分也要随机的进行多次。</li><li>自留法（bootstrap）：每次取随机取1个，然后放回，然后继续随机抽取。取到数据集的数量然后作为训练数据集。用原来没取到的进行检测。</li><li>调参与验证集<ul><li>超参数：人为定义的参数</li><li>参数：模型学习确定</li><li>验证集：训练集中专门用于调参的数据集</li></ul></li></ul></li><li>性能度量<ul><li>均方误差：E(f;D)&#x3D;$\frac{1}{m}\sum_{i&#x3D;1}^{n}(f(x_{i})-y_{i})^{2}$</li><li>错误率</li><li>精度</li><li>查准率</li><li>查全率</li><li>$F_{1}$度量，查准率和查全率的均衡考虑</li></ul></li><li>比较检验（是对不同模型学习能力的检验）<ul><li>成对T检验：就是对二者的误差做差值，如果能力差不多，插值应该在0左右分布，均值为0</li><li>卡方检验，关注列联表的负对角线上的值</li></ul></li></ul><h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p><img src="C:/Users/E/AppData/Roaming/Typora/typora-user-images/image-20230118141143102.png" alt="image-20230118141143102"></p><p>对于一维可以直接解出其最优解。</p><p>多维就扩展一个向量，把b也·放进解的内容里。</p><p>一般是解不出来的，所以会用牛顿法或者梯度下降的方式来求解</p><p>logistics回归</p><p>将线性的模型转化为$ln(\frac{y}{1-y})$来求解。此时y的输出为0和1,对该函数进行线性回归。</p><p>这个函数的来源是为了求解分类模型。最开始的回归方程是</p><p>将其写为一个分段函数，但是不可导，所以将其换为$y&#x3D;\frac{1}{1+e^{-z}}$</p><p>但是这个函数不存在导数为零的解。所以不能直接求偏导来解</p><p>所以使用一个类似于极大似然估计的想法。</p><p>把预测的概率和现实的概率乘起来，在相加。由于计算机可能会对小数在相乘时取0，所以在外面求对数。</p><p>用梯度下降的方式来优化这个对数。</p><p>分类不均问题</p><p>上面主要是进行一个二分类，但是有时后二分类的权重不同，解决方法</p><ul><li>​欠采样：就是把在多的那一类中，每次采样都取与少的类一样的样本数。多次进行，看那种结果比较好。</li><li>过采样：不能直接复制，要在相邻的样本的连线之间插入一个新的样本</li><li>阈值移动：就是改变$\frac{y}{1-y}$的值，这样就会较好的分类</li></ul><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>信息熵：描述信息的纯度</p><p>信息增益：描述通过某种划分，信息熵的减小程度，每个信息熵都要乘以该划分下的权重，没有缺失值的时候就是数量权重</p><p>处理缺失值：一种可以直接抛弃，但当维数增大时，信息难免会有缺失，此时直接抛弃就会丢失很多信息</p><p>​      算信息熵的时候只能用已有信息来计算，跳过信息缺失的进行计算，在最后的信息增益部分需要乘以信息没有缺失的信息占总信息数的比重</p><p>​进行属性划分的时候，需要按照该划分已知正类中信息的比例作为权重来划分。</p>]]></content>
    
    
    <categories>
      
      <category>---机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>---机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
